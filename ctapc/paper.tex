\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{The Design of Shallow State Blockchain*\\
{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
should not be used}
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
}

\maketitle

\begin{abstract}
Cryptocurrency based on blockchain is a peer to peer trading system.
In this decentralized system, each node maintain a complete ledger which records entire transaction history of all account.
The system has the characteristics that it is very hard to tamper with the data.
However, such characteristic only makes the data increase but do not decrease.
Years after years, requirement to single node will get higher and higher.
Once some entities get overwhelmed, the degree of centralization of this blockchain system will gradually rise

Dealing with the issue, stateless blockchain is a promising approach.
To be more specific, in this system, each transaction is attached with proof of validity.
With this approach, there is no need for a node to access the disk to search past information of the ledger.
Instead, node only verifies the proof attached to each transaction.
Therefore, it will significantly reduce the space of data storage for each node.

In this paper, we will discuss the following two points.
First, it only need to cache part of information instead of attaching proof to each transaction.
It is highly possible to infer the validity of a transaction from other valid transaction appearing recently.
Second, when blockchain forks, it have to go back to the bifurcation point and create new cache of new blocks.
To reach the purpose, we propose an immutable data structure so that cache can be rapidly computed under any situation.
Finally, we conduct the experiments with different workload to understand the performance of different cache strategies and data structures
\end{abstract}

\begin{IEEEkeywords}
blockchain, stateless blockchain, data structure
\end{IEEEkeywords}

\section{Introduction}
In 2008, Satoshi Nakamoto proposed the white paper of bitcoin. It is a new type of cryptocurrency system based on blockchain. In this system, each node maintain a complete ledger in order to attain the high degree of decentralization of entire system. However, as the data size of ledger got bigger and bigger, storage space of node increased yearly. Ten years later, it costs hundreds of GB storage space for a node to run some well-known cryptocurrency system, such as Bitcoin and Ethereum. Thus, it gradually make the nodes maintained by person overload. If we settle for second best by saving the information needed for verifying new block, such as UTXO in Bitcoin and world state in Ethereum, it still needs several or tens of GB for disk storage place. With this method, not only the storage space of disk is requested but also  I/O speed. Furthermore, it is too slow for traditional disk to access randomly. The speed of verifying a block on Ethereum can't keep up with the generation speed of blocks. It force the node maintainer on Ethereum to buy expensive solid-state disk, and it further cause the increase in operation cost of node.

To deal with the problem above, cryptocurrency communities start trying several solutions, and stateless blockchain is prospective one of them. It only need to store block header for each node on stateless blockchain. Nevertheless, each transaction must be attached with proof of validity. This approach significantly reduces the requirement of storage space. Furthermore, it is no need to search the validity of transaction on disk; namely, it drastically reduces the I/O time.

This paper proposes an imrpovement to stateless blockchain. We let the node on stateless blockchain reach a consensus to maintain a cache. If the payer of transaction appears in recent transaction, it is highly possible to infer the validity from cache. Hence, due to the omission of proof of validity, it reduces the size of transaction and the Internet traffic while broadcasting. However, how to maintain cache effectively becomes a new problem. When a new block append to the blockchain, there will be a correspondent cache. Nevertheless, there will also exist overlap on the blocks nearby. Therefore, we design persisted data structure for different cache strategies, such as the nearest k blocks and LRU, and we conduct an experiment to test their performance.

The remaining sections are arranged as follows. Section II narratives some related works, whereas section III describes the background of this paper and preliminary knowledge; section IV illuminates the design of stateless blockchain, including cache strategies and data structures used by cache; section V shows the design and results of experiment; section VI discusses future extensions to stateless blockchain, and concluding remarks are found in section VII.


\section{design}
In order to reduce occupied space of the disk, it is necessary for a stateless blockchain to attach a proof to each transaction. However, this move will increase Internet traffic. Furthermore, to reduce the time of accessing disk, it will cost computational power for CPU to verify the proof.
Compared to normal blockchain, stateless blockchain made some trade-offs. Regarding the purpose of shallow-state blockchain, the trade-offs are no longer all or nothing, which means that all transactions are attached with proofs or none of transactions are attached with proofs. It makes the degree of state storage adjustable.

\subsection{shallow-state blockchain}
In stateless blockchain, if payers and payees in some transactions are the same, the proofs in these transactions will be identical. It is obvious that the same proofs can be omitted in a block. Extended by this idea, if we cache the accounts’ information appearing in recent transactions, there is no need to verify the proof again when the accounts make transactions. To go a step further, if nodes on the Internet follow the same set of rules to record cache, it will reach a consensus that node knows whether to attach the proof. While broadcasting the block, nodes can get rid of unnecessary proofs, and then reduce internet traffic.

\subsection{cache design}
The problems mentioned above can be avoided by a simple design principle. Namely, each block has its own cache, and the content of cache depends on which chain the block is situated. Therefore, we turn a tree structure into a list, and it is definitely identical for the block on different nodes. If every node uses the same deterministic algorithm to compute the cache from this list, it can ensure that every node gets identical results of cache after verifying the same block.

\subsection{persistent cache}
In this part, we take another approach: every block retains its own cache. When a new block is about to append to the chain, it can directly use the cache of the previous block. Thus, there is no need to compute cache again. In other words, we adopt fully persistent data structure to store cache. Everytime the chain gets a new block, it creates a new version of cache.
In this method, we have to delete the cache of older blocks, such as the block 20 blocks far from the newest one, in order to limit the size of cache to a certain range. Otherwise, it will run out of memory, and it will violate our design principle.
Adopting this method leads to a new problem. If we duplicate the cache of the previous block, the space of cache will be proportional to the cache numbers that we didn’t delete. However, there is a high similarity of the cache in adjacent blocks. If we use appropriate data structure to have the cache shared by adjacent blocks, it will effectively increase space usage.

\subsection{LRU}
LRU is an acronym for “least recently used”. In this strategy, the size of cache is fixed. If a cache is full, it will discard a piece of data before inserting new data. The least recently used data are chosen by LRU strategy, and it will be discarded.
The reasons why LRU has higher hit rate than FIFO are revealed by the history data of Ethereum. First, after an account spends money, it is highly possible that it will spend money again. Second, after an account receives money,  it is highly possible that it will spend money right away. Because LRU updates the using time of data, it is able to keep caching the data appearing frequently. However, FIFO only looks at the coming time of data. Even if some data appear frequently, they will be discarded sooner or later.
From an abstract view, LRU is a data structure that supports two kinds of interface.
\begin{itemize}
\item get(key)
\item put(key, value)
\end{itemize}
When executing get(key), LRU will determine whether the key exists. If the key exists, it will return the value and update its using time.
When executing put(key, value), LRU will determine whether the space of LRU is full. If the space of LRU isn’t full, the key-value pair will be inserted to the space directly.  If the space of LRU is full, LRU will find out the least recently used one in the cache and abandon it, and then insert the new key-value pair to it. The using time of the new key-value pair should be the latest.
Corresponding to the situation of stateless blockchain, everytime when a new block appends to the chain, we have to compute the cache of the new block. In this time, a series of read and modify execution of accounts will turn into get and put. Key will be the address of account, and value will be the state of account. Finally, the underlying data structure of LRU will take the correspondent action.

\subsection{persistent LRU algorithm}
Before discussing persistent LRU algorithms, we first observe how to efficiently implement LRU cache on software. Judging from several popular LRU libraries on github, interior data structures are all combinations of hash table and doubly linked list.
While executing get, it will get the data by the pointer pointing to the node of list. Then, the node will move to the head of the list. While executing put, if cache hits, the value of node will be updated, and the node will move to the head of the list. If cache is not full, the cache value will be added to the head and the pointer will be put in the hash table. Instead, if the cache is full, pull out the tail node of the doubly linked list, and delete the old key in the hash table. Then, add cache value to the head and put the pointer in the hash table.
We observed that there are two kinds of information that need to be recorded by LRU.
\begin{enumerate}
  \item find the value from key (key-value pair)
  \item the order information of all keys
\end{enumerate}
In the implementation of combinations of hash table and doubly linked list, hash table is responsible for (1), and doubly linked list is responsible for (2). We observed that a doubly linked list records the order relationship naturally, and it doesn't even need to record the definite using time.
There is one simple idea that we directly combine persistent-versioned alternatives of a hash table and a doubly linked list, and then we get a persistent LRU. Although there are mature alternatives for hash tables, it is hard to find such a thing for doubly linked lists.
Thus, we need to use other persistent and efficient data structures to replace doubly linked lists. The things that an abstract doubly linked list can do are as follows.
\begin{itemize}
\item Update the using time of node to latest
\item Delete the least recently used node
\item Insert new node and update the using time of the node to latest
\end{itemize}
Following we will discuss how to use red-black tree to complete the above tasks and introduce our design of order tree, which is more efficient than red-black tree.

\subsection{hash table + red-black tree}
We tried to use red-black to record the order information.
First, set a unique timestamp for every account.
This timestamp is easy to access. For instance,
it could be $block\_height * max\_tx\_in\_one\_block+ tx\_number$.
Afterwards, build a red-black tree whose key is timestamp and value is account’s information. About hash table, the account's address is set as key and the correspondent timestamp is set as value.
While executing get, it first gets the timestamp from the account's address in the hash table, and then gets the account’s information from the timestamp in the red-black tree. For example, in Fig 3.6, we first get the account’s timestamp, 243, from the hash table, and search 243 in red-black tree.
After searching, it needs to update the using time. The specific operations are that modify the timestamp corresponding to the address in the hash table and remove the original node in red-black tree. Then, set the new timestamp as key. The put operation is similar to get operation. However, it needs to modify the account's information. 
Fig 3.6 shows the sharing structure of the persistent red-black tree. In this figure, the cache size is 8. In state 1, there are only 7 data. After that, state 2 insert 14 in it, and there are 8 data. State 3 insert 15 to state 2, and the cache is full. Therefore, it has to delete the data of minimum timestamp; that is, the red 7 at lower left corner will be deleted.


\section{Related Work}
\subsection{Utreexo}
Utreexo~\cite{b1} applying the Merkle forest to  design a new accumulator.
Based on this accumulator, the Utreexo node does not need to actually store all of the UTXO and is still able to verify the blocks.

However, the bitcoin network has been around for years, and it's not realistic to drastically modify the protocol so that all nodes become stateless.
Utreexo proposes that a bridge node could be used as an intermediary between the bitcoin full node and the Utreexo node.
When the block broadcasts from the Utreexo node to the full node, the proof is stripped away, on the other hand, the proof is placed.

The paper also mentions that, analyzing the historical record of bitcoin
About 40\% of UTXO will be consumed in 20 blocks.
Nearly 80\% of UTXO will be consumed in 1000 blocks.
So by using a small amount of memory space to cache the most recent UTXO, you can skip transmitting many proofs.

The difference from this study is that this study considers account-based cryptocurrencies, rather than UTXO-based ones.
At the same time, this study additionally considers the situation when bifurcation occurs.

\subsection{Making Data Structure Persistent}

The paper~\cite{b2} proposes a variety of algorithms that enable any node-based data structure to be partial/fully persistent.
According to the node-splitting algorithm of that paper, it is even possible to complete the insertion and modification of a doubly linked list within the $O(1)$ time complexity.

However, the paper does not propose a way to remove older versions of the persistent data structure.
This makes it difficult to apply these algorithms to the caching of shallow state blockchains.
Because the inability to delete past versions will result in the space needed for caching never being released.


\begin{thebibliography}{00}
\bibitem{b1} Dryja, Thaddeus. Utreexo: A dynamic hash-based accumulator optimized for the Bitcoin UTXO set. Vol. 2019. IACR Cryptology ePrint Archive, 2019.
\bibitem{b2} Driscoll, James R., et al. "Making data structures persistent." Proceedings of the eighteenth annual ACM symposium on Theory of computing. 1986.
\end{thebibliography}
\vspace{12pt}
\color{red}
IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
