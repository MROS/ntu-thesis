\chapter{實驗設計與結果}
\label{c:experiment}

在本章中，我們將在不同工作量下評估
以不同資料結構分別實作的持久化 LRU 性能。

\section{實驗環境}
實驗均在以下環境中進行

\begin{itemize}
\item CPU： AMD Ryzen 7 2700X (8 核心 16 執行緒、3.6 GHz、32K L1d 快取、64k L1i 快取、512K L2 快取、8M L3 快取)
\item 記憶體： DDR4 64 GB
\item 作業系統：Linux manjaro 4.19.36-1-MANJARO x86\_64
\item 編譯器： GCC 9.1.0
\end{itemize}

\section{資料結構}

我們以 C++ 17 撰寫了三種資料結構：

除了 3.4.1 節提到的持久化雜湊 + 持久化紅黑樹，
以及 3.4.2 節提到的持久化雜湊 + 持久化值無關順序樹之外，
還實作了雜湊 + 雙向鏈表的資料結構，
這是最簡易的持久化 LRU 實作，
它的各項操作與我們在 3.4 節介紹的暫時性 LRU 資料結構相同，
但當它需要創建新版本時，
會複製一份舊版本再繼續操作，
我們以此來對照具有共享結構特性的其他兩個持久化資料結構。

\begin{itemize}
\item 雜湊 + 雙向鏈表（3.4 節）
\item 持久化雜湊 + 持久化紅黑樹（3.4.1 節）
\item 持久化雜湊 + 持久化值無關順序樹（3.4.2 節）
\end{itemize}

由於要模擬的是區塊鏈，所以所有的工作量都以區塊為單位，
而一個區塊會包含多個 get/put 。
為此，以上三種的持久化資料結構的實作都支援了 transient \cite{puente2017persistence}，
也就是說，資料結構不需要對每一個 get/put 都生成一個新版本，而是暫時生成一個版本，
在其上進行多個操作，再將它固定為不可變的，
由於減少了大量的中間狀態，此舉能夠大幅提升效能。

函式庫使用方面，雜湊直接使用了 C++ 標準函式庫的 unordered\_map ，
持久化雜湊則採用了著名的 C++ 不可變資料結構函式庫 \href{https://sinusoid.es/immer/}{immer} ，
其餘的雙向鏈表、持久化紅黑樹、持久化值無關順序樹則自行撰寫。

往後，我們會以雙向鏈表、紅黑樹、值無關順序樹來簡稱這三個複合資料結構。

\section{速度}

\subsection{工作量}
我們採用一個簡單的模型來模擬區塊生成，網路中有 n 個節點，
每個節點都會針對自己認定的最高區塊（亦即，它所認同的最長鏈的頂端）挖礦，初始時，
每個節點的最高區塊都是創世區塊(genesis block)。其後，有若干回合，
每個回合中，每個節點有一定概率會挖出新區塊。若它沒有挖到，
則會投奔其他節點挖出的同最高區塊的後繼區塊，若該最高區塊沒有任何後繼區塊，
則會隨機投奔其他最長鏈。若沒有任何節點挖到礦，就將同樣的過程再來一次。

在所有的工作量中，都是假定網路中有 10 個節點、每個節點在一個回合內挖到礦的機率是十分之一，
並且在挖出 1000 個區塊之後停止。在此設定下，同個高度大約會有 1.5 個區塊。

從 \href{https://etherscan.io/chart/gaslimit}{etherscan} 可以得知，
以太坊現今的 gas limit 大約是一千萬，而一筆交易的 gas 費用為 21000 ，
一個區塊大約可以包含 500 左右的交易。因此工作量的一個區塊的 get/put 指令數量設定為 500 。

此外，還有一項參數是 get/put 的佔比，對於一般的以太坊交易而言，
每次的付款都會導致賬戶的狀態改變，然而智慧合約的情形就不一定，
因此 get, put 兩種指令都有可能出現，以下若無額外說明，put 都占 50\% （get 也占 50\%）。

在開始任何一項工作前，我們都會先將整份快取裝滿，若非如此，當快取大小設定太大時，
需要很長一段時間才能將它裝滿，快取未滿時的狀態並非我們關注的，因為區塊鏈動輒幾百萬個區塊，
極大部分時間，快取都是裝滿的。

\subsection{調整快取大小}

第一項實驗將快取命中率固定在 100\% ，調節快取的大小（鍵值對的數量）。

\begin{figure}[h!]
\includegraphics[width=\textwidth]{調整快取大小}
\caption{調整快取大小}
\end{figure}

所畫出的折線圖 4.1，可以看出，雙向鏈表所耗費的時間基本上正比於快取的大小，
顯見雙向鏈表的主要消耗在於複製，快取有多大，每次區塊更新，所要複製的量就有多大。

紅黑樹和值無關順序樹的成長曲線就十分平緩（$O(\log n)$），而值無關順序樹的常數又小於紅黑樹。
注意到值無關順序樹的折線中，相較紅黑樹的穩定增長，是有所震盪的，
這跟值無關順序樹的葉子數量是 $1 + \lceil \log_2 n \rceil$ 有關，它的葉子數量更加離散，
當快取大小達到 $2^k$ 次方時，葉子數量往上翻倍，此時就會影響效能，導致震盪。

\subsection{調整快取命中率}

將快取大小定為 30000 ，調整命中率 。

\begin{figure}[h!]
\includegraphics[width=\textwidth]{調整命中率}
\caption{調整命中率}
\end{figure}

圖 4.2 中可見，命中率對雙向鏈表並沒有什麼影響，因為它的主要消耗來自於複製，
快取命中之後要做的事情只是搬動幾個指標，不花什麼時間。
而紅黑樹、值無關順序樹的耗時都會隨命中率提高而有所上升，
因為它們主要的耗時來自於路徑複製，命中越多，需要複製、創建的分支也就越多。

\subsection{調整 put 比例}

將快取大小定為 30000 ，命中率設為 1.0 ，調整 put 佔兩種指令的比例。從圖 4.3 可見基本不影響效能。

\begin{figure}[h!]
\includegraphics[width=\textwidth]{調整put比例}
\caption{調整 put 比例}
\end{figure}

% \subsection{記憶體用量}

\section{失效代價（miss penalty）}

如果驗證一筆交易時，它相關賬戶的資訊不在節點的快取中（快取失效），
這筆交易就得附上證明以供節點驗證。因此快取失效的代價有二：
(1) 接收證明所需要的網路 I/O ，這與證明所佔的空間有直接關係。
(2) 驗證證明所消耗的 CPU 運算時間。

而快取命中所耗費的時間，我們可以觀察圖 4.3 ，
值無關順序樹實作在快取大小 30000 、put 比例 100\%、命中率 1.0 時，
 1.241 秒內執行了 1000 個區塊，而一個區塊中有 500 條指令，
亦即一個區塊的平均執行時間是 1.241 毫秒，當快取更小的時候，這個數字還會更低。

我們挑選最常見的梅克爾 Patricia 樹的驗證成本來與值無關順序樹實作比較，
函式庫選用了兩大以太坊實作之一的 \href{https://www.parity.io/ethereum/}{Parity Ethereum}
的 \href{https://docs.rs/trie-db/0.20.1/trie_db/index.html}{trie-db} 模組。

影響梅克爾 Patricia 證明的因素有二：
(1) 葉子的數量 $s$ ，證明的大小就約為 $O(\log s)$ ， 要驗證一個證明的時間複雜度也是 $O(\log s)$ 。
(2) 批量處理時，一批的數量。梅克爾證明就是梅克爾樹的一個分支，當一個節點被多個分支共享時，不必重複計算，
因此一次驗證 $k$ 個證明的時間會短於 $k$ 乘以驗證一個證明的時間。

由 \href{https://www.etherchain.org/charts/totalAccounts}{etherchain.org} 的資料我們可以得知，
現今的以太坊賬戶數量已經超過八千萬，
所以我們先在梅克爾 Patricia 樹中隨機插入八千萬筆資料（也就是說葉子的數量為八千萬），
並且根據此前一個區塊中 500 個交易的假設，批量驗證 500 個證明，
量測得到所費時間 5.536 毫秒，明顯要比直接取用快取來得耗時。

而一個區塊的證明大小約為 900 KB ，1000 個區塊就是將近 900 MB ，
若使用當今一般的家用網路，下載這些額外證明所需的時間又比驗證證明更加耗時。

\section{總結}

實驗驗證了值無關順序樹、紅黑樹較低的時空間複雜度，在快取大小增大到一定程度後，
表現上顯著領先總是複製自身的雙向鏈表。 而值無關順序樹相較於紅黑樹，
在效能上並無顯著優勢，但其在概念上易於理解\footnote{作者主觀認知}（無各種旋轉規則需記誦），
時間複雜度相當，若未來有人想於無狀態區塊鏈上實作 LRU 快取，
亦可考慮使用值無關順序樹。

同時也實驗、量測了梅克爾 Patricia 樹的證明大小以及驗證速度，
瞭解到通常情況下直接讀取快取要比下載、驗證證明要來得快速。
根據這些數據，能夠推論若以梅克爾 Patricia 樹做為 vector commitment 時，
淺狀態區塊鏈若採取適當的快取大小，能夠在 LRU 策略下帶來速度提升。